# TypeScriptによるエージェントの最小構成と設計思想

このドキュメントは、生成AIエージェント開発ロードマップの最初の一歩（フェーズA）として取り組んだ「TypeScriptによる最小構成エージェント」の実装内容と、その背後にある設計思想をまとめたものです。

いわゆる「AIっぽい」機能の実装を急ぐのではなく、まずはエージェントという仕組みを一つのソフトウェア構造として捉え、制御可能なものにすることを優先しました。

---

## 1. このフェーズで目指したもの

今回の最大の目的は、**LLMを「プロンプトで動く賢いチャットボット」ではなく、「状態を持ち、自律的に動くシステム」の一部として組み込むこと**にあります。

エンジニアとしてAIを扱う際、どうしても「いかに賢いプロンプトを書くか」「いかにLLMの性能を引き出すか」に目が行きがちです。しかし、プロダクトとしてスケールさせるためには、LLMの「賢さ」に依存するのではなく、システムとしての「制御可能性」を担保することが不可欠だと考えました。

### 最小構成にする理由
* **構造の理解**: 複雑なライブラリを使わず、自前でループを組むことでエージェントの本質を理解する。
* **拡張性**: 基礎となる構造（スケルトン）がしっかりしていれば、後からRAGやマルチエージェント化といった「賢さ」をいくらでも追加できる。
* **デバッグ可能性**: LLMの出力という不確実な要素を、コードと状態（State）によって追跡可能にする。

---

## 2. エージェントを支える4つの構成要素

本実装では、エージェントの役割を以下の4つに明確に分離しました。これにより、各要素が独立してテスト・改善できる構造になっています。

| 要素 | 役割 | 意図 |
| :--- | :--- | :--- |
| **State（状態）** | 世界の真実 | 今何が起きていて、何が未完了なのかを保持する唯一のリソース。 |
| **Planner（計画）** | 戦略の策定 | Stateを見て「次に何をすべきか」を判断する。LLMが主に活躍する場所。 |
| **Executor（実行）** | 具体的なアクション | Plannerが決めた指示に基づき、実際にAPIを叩く、ファイルを読み書きするなどの「手足」となる機能。 |
| **Evaluator（評価）** | 結果の吟味 | アクションの結果が意図通りか、目標（Goal）に近づいているかを判断する。 |

### 「State」を設計の中心に据える
本プロジェクトで最も重視したのは、**Stateが唯一の真実（Single Source of Truth）である**という点です。

```ts
type AgentState = {
  goal: string;
  tasks: Task[];
  currentTaskIndex: number;
  artifacts: Record<string, any>;
  issues: string[];
  done: boolean;
}
```

LLMに直接ロジックを委ねるのではなく、LLMはあくまで「Stateから次のアクションを生成する関数」として扱います。プログラム側でこのStateを管理し、継続・終了の判断を行うことで、Reduxやステートマシンのような予測可能な制御を実現しました。

---

## 3. 「考える → 行動する → 反省する」自律ループ

エージェントが単なるスクリプトと異なるのは、自身の行動結果を振り返り、必要に応じて計画を修正するループを持っている点です。

```ts
while (!state.done) {
  // 1. 今の状況から計画を立てる
  const plan = planner(state);
  
  // 2. 計画を実行する（副作用の発生）
  const result = executor(plan, state);
  
  // 3. 実行結果を評価し、Stateを更新する
  const evaluation = evaluator(result, state);
  state = update(state, evaluation);
}
```

この「自己修正ループ」こそがエージェントの最小要件です。一発で正解を出せなくても、ループを回すことで目標に近づいていく。この構造こそが、非決定的なLLMを実務で使うための鍵となります。

---

## 4. エンジニアとして押さえておくべき本質

実装を通じて得られた、エージェント設計における重要なポイントを整理します。

### プロンプトは「設定」であり「ロジック」ではない
プロンプトをいじって挙動を調整するのは限界があります。エージェントの振る舞いを決定づけるのは、プロンプトの内容そのものよりも、**どのようなデータ構造（State）をLLMに渡し、その結果をどうコードで受けるか**という設計そのものです。

### LLMは「副作用」を伴う部品として扱う
LLMは失敗するし、コストもかかるし、何より出力が安定しません。だからこそ、Executor（実行部）は極力シンプルにし、LLMに複雑な判断を分散させないことが大切です。賢さはPlannerやEvaluatorに集約し、それ以外は純粋なプログラムとして記述します。

### スケールするための土台
この最小構成は、将来的に以下のような発展をさせる際の共通基盤になります。
* **RAG連携**: 過去の履歴や外部知識をStateに注入する。
* **マルチエージェント**: 他のエージェントのEvaluatorとして別のLLMを立てる。
* **UI連携**: 実行途中のStateをユーザーに見せ、手動で介入（Human-in-the-loop）できるようにする。

---

## 5. まとめと次のステップへ

フェーズAを終えたことで、「エージェントとは何か」を言語化し、コードで表現できる土台が整いました。単に「AIを使って何かを作る」のではなく、「AIを制御可能な部品としてシステムに組み込む」視点が得られたことが最大の収穫です。

次は、この堅牢な構造の上に、より実用的な機能を載せていきます。

**次フェーズ（フェーズB）の展望**
* JSONベースのスライド生成ロジックの実装
* レイアウト評価アルゴリズムとの連携
* 視覚的なフィードバックに基づく修正ループの強化

この「土台」があるからこそ、次からの実装は一気に実務レベルへと加速させていくことができます。
